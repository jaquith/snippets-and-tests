<script type="text/javascript">

/*

A Custom HTML Tag for Google Tag Manager that sends consent decision events to Tealium's Collect API if:
 - the user has opted OUT of Tealium AudienceStream tracking (for marketing purposes) AND
 - there is an ID we can use to identify the user, EITHER
    - a previously set tealium_visitor_id (stored in the TEAL cookie), OR
    - a login-based ID - the customer is logged in, which gives us a key for stitching

Without one of those two IDs for identity resolution, any event would never be connected back to
the user (because the tealium_visitor_id would be randomly generated by the endpoint).

If the user opts in, no event is fired (but it's fine to still trigger this tag). It contains logic to only fire

----

ASSUMES: Google Tag Manager (Tag Manager) and Usercentrics (Consent Manager)

----

TRIGGER: on consent change event and login events

----

VERSION: 1.0

*/

var payload = {}

// Start config
payload.tealium_account = '{{Constant - Tealium - Account ID}}'
payload.tealium_profile = '{{Lookup - Tealium - Profile}}'

payload.tealium_event = 'consents_changed_finished'

var customerIdPropertyNameInPayload = 'customer_id'
payload[customerIdPropertyNameInPayload] = '{{DL - customer - customerID}}'

// Replace any whitespace with an underscore
var cleanTealiumNameInUsercentrics = 'Tealium_Inc'
// End config

// Will be undefined if no cookie is found
payload.tealium_visitor_id = getExistingCookieId()
// Remove the tealium_visitor_id property if it's undefined so that the server auto-generates a random one
if (!payload.tealium_visitor_id) {
  delete payload.tealium_visitor_id
}

// Will be the string "undefined" if the user isn't logged in
// Remove the login-based property if it's undefined/empty to avoid unintended behavior
if (!payload[customerIdPropertyNameInPayload] || payload[customerIdPropertyNameInPayload] === "undefined") {
  delete payload[customerIdPropertyNameInPayload]
}

var latestConsentChange = getConsentChangeFullDecision()

// Replace each stretch of whitespace with an underscore - CDH doesn't support whitespace in attribute names
var keys = Object.keys(latestConsentChange)
var cleanKey
keys.forEach(function (key){
  if (key === 'event' || key.indexOf('gtm.') === 0) return
  // Replace each stretch of whitespace with an underscore
  cleanKey = key.replace(/\s+/g, '_')
  payload[cleanKey] = latestConsentChange[key]
})

/* 

Only send the consent request through this tag if:
  - Tealium AudienceStream is opted out AND  
  - we have EITHER
    - a previously-set Tealium cookie OR 
    - a login-based id to use for stitching

Otherwise we'll either get it through the normal Collect tag, or not be able to do anything meaningful with the data.

*/

var foundAtLeastOneId = !!payload.tealium_visitor_id || !!payload[customerIdPropertyNameInPayload]
var collectTagWillFire = payload[cleanTealiumNameInUsercentrics] === true
var shouldFire = collectTagWillFire === false && foundAtLeastOneId === true

if (shouldFire) {
  var xhr = new window.XMLHttpRequest()
  xhr.open("POST", 'https://collect.tealiumiq.com/event', true)
  xhr.setRequestHeader('Content-Type', 'application/json')
  xhr.setRequestHeader('Accept', 'application/json')
  xhr.send(JSON.stringify(payload))
}

// Look for the previous cookie id, return 'undefined' if it's not found
function getExistingCookieId() {
  // this is the primary cookie that we'll use for the Collect (and Consent) requests.
  var existingCookieId = getVidFromTealCookie()

  if (typeof existingCookieId === "string") {
    return existingCookieId;
  }
  
  // otherwise it will return 'undefined'

  // HELPER FUNCTIONS

  // Returns 'undefined' if no cookie found (or the cookie is missing the vid)
  function getVidFromTealCookie() {
    // TEAL is a multicookie like
    // TEAL=v:7178214980882450500161155686637798856717aaa$t:1615467968467$s:1615466168460%3Bexp-sess$sn:1$en:1
    // where 'v' is the value we want to get
    var fullCookie = readCookie('TEAL')
    if (typeof fullCookie !== 'string') return
    var parts = fullCookie.split('$')
    var key, value, both

    for (var i = 0; i < parts.length; i++) {
      both = parts[i].split(':')
      key = both[0].trim()
      value = both[1].trim()
      if (key === 'v') return value;
    }
  }

  function readCookie(name) {
    var reString = '(?:(?:^|.*;\\s*)' + name + '\\s*\\=\\s*([^;]*).*$)|^.*$';
    var re = new RegExp(reString)
    var cookieValue = document.cookie.replace(re, "$1")
    if (!cookieValue) return undefined;
    return cookieValue;
  }
}

function getConsentChangeFullDecision () {
  var oldDecision = getLatestEventByName('consents_initialized')
  var foundConsentChange = oldDecision
  // go from oldest to newest this time, to make sure all updates are correctly captured
  for (var i = 0, entry, keys, values; i < dataLayer.length; i++) {
    if (dataLayer[i] && dataLayer[i].event === 'consents_changed_finished') {
      entry =  JSON.parse(JSON.stringify(dataLayer[i]))
      keys = Object.keys(entry)
      values = Object.values(entry)
      keys.forEach(function (key, index){
        foundConsentChange[key] = values[index]
      })
    } 
  }
  return foundConsentChange
}

// Returns false if not found 
function getLatestEventByName (eventName) {
  if (!eventName) return false
  var entry
  for (var i = dataLayer.length - 1; i > -1; i--) {
    if (dataLayer[i] && dataLayer[i].event === eventName) {
      // remove this, not always present, but not useful for our purposes
      entry =  JSON.parse(JSON.stringify(dataLayer[i]))
      delete entry.usc_origin
      return entry
    }
  }
  return false
}


</script>